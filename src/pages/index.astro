---
import Layout from '@/layouts/Layout.astro';
import Hero from '@/components/Hero.svelte';
import Projects from '@/components/Projects.svelte';
import Skills from '@/components/Skills.svelte';
import OtherProjects from '@/components/OtherProjects.svelte';
import Contact from '@/components/Contact.svelte';

// Hardcoded featured repositories
const USERNAME = 'Napolitain';
const ORG_NAME = 'fds-napolitain';

// Hardcoded featured projects instead of relying on API calls
const FEATURED_REPOS = [
  'twoptimizer',
  'liquipedia-calendar',
  'go-creator'
];

async function fetchGitHubData() {
  try {
    // Fetch specific repositories for featured projects
    const pinnedRepos = await Promise.all(
      FEATURED_REPOS.map(async (repoName) => {
        try {
          const response = await fetch(`https://api.github.com/repos/${USERNAME}/${repoName}`);
          if (!response.ok) return null;
          const repo = await response.json();
          
          return {
            id: repo.id,
            name: repo.name,
            full_name: repo.full_name,
            description: repo.description,
            html_url: repo.html_url,
            stargazers_count: repo.stargazers_count,
            forks_count: repo.forks_count,
            language: repo.language,
            topics: repo.topics || [],
            fork: repo.fork,
            owner: {
              login: repo.owner.login
            }
          };
        } catch (err) {
          console.error(`Failed to fetch ${repoName}:`, err);
          return null;
        }
      })
    );
    
    // Fetch user repos
    const userReposResponse = await fetch(`https://api.github.com/users/${USERNAME}/repos?sort=updated&per_page=100&type=owner`);
    const userRepos = await userReposResponse.json();
    
    // Fetch org repos
    let orgRepos = [];
    try {
      const orgReposResponse = await fetch(`https://api.github.com/orgs/${ORG_NAME}/repos?sort=updated&per_page=100`);
      orgRepos = await orgReposResponse.json();
    } catch (error) {
      console.error('Failed to fetch org repos');
    }
    
    // Combine and deduplicate
    const allRepos = [...userRepos, ...orgRepos];
    const uniqueRepos = Array.from(
      new Map(allRepos.map((repo: any) => [repo.id, repo])).values()
    ).filter((repo: any) => !repo.fork);
    
    // Extract skills
    const languages = new Set<string>();
    const topics = new Set<string>();
    
    uniqueRepos.forEach((repo: any) => {
      if (repo.language) languages.add(repo.language);
      if (repo.topics) repo.topics.forEach((topic: string) => topics.add(topic));
    });
    
    const allSkills = [...languages, ...topics];
    
    return {
      pinnedRepos: pinnedRepos.filter((r: any) => r !== null && !r.fork),
      allRepos: uniqueRepos,
      skills: {
        all: allSkills,
        categorized: categorizeSkills(allSkills)
      }
    };
  } catch (error) {
    console.error('Error fetching GitHub data:', error);
    // Fallback to JSON file if fetch fails
    const githubData = await import('@/data/github-data.json');
    return {
      pinnedRepos: githubData.pinnedRepos,
      allRepos: githubData.allRepos,
      skills: githubData.skills
    };
  }
}

function categorizeSkills(skillsArray: any[]) {
  // Create a Map from the skills array
  const skillsMap = new Map();
  skillsArray.forEach((item: any) => {
    if (typeof item === 'string') {
      // Old format - assume count of 1
      skillsMap.set(item, 1);
    } else {
      // New format with name and count
      skillsMap.set(item.name, item.count);
    }
  });
  
  // Filter skills that appear at least twice
  const filteredSkills = new Map();
  skillsMap.forEach((count, skill) => {
    if (count >= 2) {
      filteredSkills.set(skill, count);
    }
  });
  
  // Comprehensive categorization based on the issue requirements
  const categories = {
    // Languages - programming languages
    languages: new Set([
      'typescript', 'python', 'go', 'c++', 'javascript', 'c#', 'java', 'kotlin', 
      'netlogo', 'c', 'cpp', 'csharp', 'js'
    ]),
    
    // Frontend - UI/UX frameworks and libraries
    frontend: new Set([
      'svelte', 'nextjs', 'react', 'next', 'vue', 'angular', 'astro', 
      'tailwind', 'bootstrap', 'canvas'
    ]),
    
    // Backend & Databases - server-side and data storage
    backend: new Set([
      'flask', 'redis', 'node', 'express', 'django', 'spring', 'rails', 
      'laravel', 'fastapi', 'nestjs', 'postgresql', 'mysql', 'mongodb', 
      'elasticsearch', 'graphql', 'caldav-server', 'network'
    ]),
    
    // Tools & DevOps - development tools, build systems, and DevOps
    tools: new Set([
      'docker', 'kubernetes', 'jenkins', 'gitlab', 'github-actions', 
      'terraform', 'ansible', 'aws', 'azure', 'gcp', 'git', 'cmake', 
      'dotenv', 'puppeteer', 'headless-chrome'
    ]),
    
    // Game Development - game engines, graphics, and game-related technologies
    gamedev: new Set([
      'unity', 'game-development', 'game-engine', 'opengl', 'shaderlab', 
      'raytracing', 'game', 'qt'
    ]),
    
    // AI & Machine Learning - artificial intelligence and machine learning
    aiml: new Set([
      'ai', 'artificial-intelligence', 'tensorflow', 'genetic-algorithm', 
      'linear-programming', 'operations-research'
    ]),
    
    // Computer Vision & Graphics - image processing and computer vision
    vision: new Set([
      'opencv', 'image', 'image-processing', 'inpainting', 'hdr', 
      'augmented-reality', 'mixed-reality', 'virtual-reality', 
      'motion-tracking', 'object-tracking'
    ]),
    
    // Multimedia & Signal Processing - audio, video, and signal processing
    multimedia: new Set([
      'ffmpeg', 'video-editing', 'music', 'dsp', 'signal-processing', 
      'digital-signal-processing'
    ]),
    
    // Desktop & Framework - desktop application frameworks
    desktop: new Set([
      'dotnet', 'tkinter', 'windows', 'uwp'
    ]),
    
    // Other Technologies - everything else
    other: new Set([
      'html', 'tex', 'total-war', 'esports', 'icalendar', 
      'liquipedia', 'web-scraping', 'keyrate', 'utility', 'bot', 
      'university', 'template', 'compression', 'security'
    ])
  };
  
  const categorized = {
    languages: [] as Array<{name: string, count: number}>,
    frontend: [] as Array<{name: string, count: number}>,
    backend: [] as Array<{name: string, count: number}>,
    tools: [] as Array<{name: string, count: number}>,
    gamedev: [] as Array<{name: string, count: number}>,
    aiml: [] as Array<{name: string, count: number}>,
    vision: [] as Array<{name: string, count: number}>,
    multimedia: [] as Array<{name: string, count: number}>,
    desktop: [] as Array<{name: string, count: number}>,
    other: [] as Array<{name: string, count: number}>
  };
  
  filteredSkills.forEach((count, skill) => {
    const lowerSkill = skill.toLowerCase();
    
    // Check exact matches first
    let categorizedFlag = false;
    
    for (const [category, keywords] of Object.entries(categories)) {
      if (keywords.has(lowerSkill)) {
        (categorized as any)[category].push({ name: skill, count });
        categorizedFlag = true;
        break;
      }
    }
    
    // If no exact match, try partial matches for complex names
    if (!categorizedFlag) {
      if (['typescript', 'javascript', 'python', 'java', 'kotlin', 'c++', 'c#', 'go'].some(kw => lowerSkill.includes(kw))) {
        categorized.languages.push({ name: skill, count });
      } else if (['react', 'vue', 'svelte', 'next', 'angular', 'tailwind'].some(kw => lowerSkill.includes(kw))) {
        categorized.frontend.push({ name: skill, count });
      } else if (['flask', 'redis', 'django', 'mongodb', 'postgresql', 'mysql', 'graphql'].some(kw => lowerSkill.includes(kw))) {
        categorized.backend.push({ name: skill, count });
      } else if (['docker', 'kubernetes', 'git', 'cmake', 'terraform', 'ansible'].some(kw => lowerSkill.includes(kw))) {
        categorized.tools.push({ name: skill, count });
      } else if (['unity', 'game', 'opengl', 'raytracing'].some(kw => lowerSkill.includes(kw))) {
        categorized.gamedev.push({ name: skill, count });
      } else if (['tensorflow', 'ai', 'artificial-intelligence'].some(kw => lowerSkill.includes(kw))) {
        categorized.aiml.push({ name: skill, count });
      } else if (['opencv', 'image', 'vision', 'augmented-reality', 'virtual-reality'].some(kw => lowerSkill.includes(kw))) {
        categorized.vision.push({ name: skill, count });
      } else if (['video', 'audio', 'music', 'ffmpeg', 'signal'].some(kw => lowerSkill.includes(kw))) {
        categorized.multimedia.push({ name: skill, count });
      } else if (['dotnet', 'tkinter', 'uwp', 'qt'].some(kw => lowerSkill.includes(kw))) {
        categorized.desktop.push({ name: skill, count });
      } else {
        categorized.other.push({ name: skill, count });
      }
    }
  });
  
  // Sort each category by count (descending) then by name
  Object.keys(categorized).forEach(category => {
    (categorized as any)[category].sort((a: any, b: any) => {
      if (b.count !== a.count) return b.count - a.count;
      return a.name.localeCompare(b.name);
    });
  });
  
  return categorized;
}

const githubData = await fetchGitHubData();
---

<Layout>
  <div class="min-h-screen">
    <Hero client:load />
    <Projects client:load githubData={githubData} />
    <Skills client:load githubData={githubData} />
    <OtherProjects client:load githubData={githubData} />
    <Contact client:load />
    
    <footer class="py-16 px-8 border-t border-border mt-40">
      <div class="max-w-6xl mx-auto text-center text-sm text-muted-foreground">
        <p>Â© {new Date().getFullYear()} Napolitain. Built with Astro, Svelte & TypeScript.</p>
      </div>
    </footer>
  </div>
</Layout>
