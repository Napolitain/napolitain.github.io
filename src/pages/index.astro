---
import Layout from '@/layouts/Layout.astro';
import Hero from '@/components/Hero.svelte';
import Projects from '@/components/Projects.svelte';
import Skills from '@/components/Skills.svelte';
import OtherProjects from '@/components/OtherProjects.svelte';
import Contact from '@/components/Contact.svelte';

// Fetch real GitHub data at build time
const USERNAME = 'Napolitain';
const ORG_NAME = 'fds-napolitain';

async function fetchGitHubData() {
  try {
    // Fetch pinned repos using GitHub GraphQL API
    const graphqlQuery = `
      query {
        user(login: "${USERNAME}") {
          pinnedItems(first: 6, types: REPOSITORY) {
            nodes {
              ... on Repository {
                id
                name
                description
                url
                stargazerCount
                forkCount
                primaryLanguage {
                  name
                }
                repositoryTopics(first: 10) {
                  nodes {
                    topic {
                      name
                    }
                  }
                }
                isFork
                owner {
                  login
                }
              }
            }
          }
        }
      }
    `;
    
    const pinnedResponse = await fetch('https://api.github.com/graphql', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'User-Agent': 'Astro-Portfolio'
      },
      body: JSON.stringify({ query: graphqlQuery })
    });
    
    const pinnedData = await pinnedResponse.json();
    
    // Transform GraphQL response to match REST API format
    const pinnedItems = pinnedData.data?.user?.pinnedItems?.nodes || [];
    const pinnedRepos = pinnedItems
      .filter((repo: any) => !repo.isFork)
      .map((repo: any) => ({
        id: Math.abs(repo.id.split('').reduce((acc: number, char: string) => acc + char.charCodeAt(0), 0)), // Generate numeric ID from GraphQL ID
        name: repo.name,
        full_name: `${repo.owner.login}/${repo.name}`,
        description: repo.description,
        html_url: repo.url,
        stargazers_count: repo.stargazerCount,
        forks_count: repo.forkCount,
        language: repo.primaryLanguage?.name || null,
        topics: repo.repositoryTopics?.nodes?.map((node: any) => node.topic.name) || [],
        fork: repo.isFork,
        owner: {
          login: repo.owner.login
        }
      }));
    
    // Fetch user repos
    const userReposResponse = await fetch(`https://api.github.com/users/${USERNAME}/repos?sort=updated&per_page=100&type=owner`);
    const userRepos = await userReposResponse.json();
    
    // Fetch org repos
    let orgRepos = [];
    try {
      const orgReposResponse = await fetch(`https://api.github.com/orgs/${ORG_NAME}/repos?sort=updated&per_page=100`);
      orgRepos = await orgReposResponse.json();
    } catch (error) {
      console.error('Failed to fetch org repos');
    }
    
    // Combine and deduplicate
    const allRepos = [...userRepos, ...orgRepos];
    const uniqueRepos = Array.from(
      new Map(allRepos.map((repo: any) => [repo.id, repo])).values()
    ).filter((repo: any) => !repo.fork);
    
    // Extract skills
    const languages = new Set<string>();
    const topics = new Set<string>();
    
    uniqueRepos.forEach((repo: any) => {
      if (repo.language) languages.add(repo.language);
      if (repo.topics) repo.topics.forEach((topic: string) => topics.add(topic));
    });
    
    const allSkills = [...languages, ...topics];
    
    return {
      pinnedRepos: pinnedRepos.filter((r: any) => r !== null && !r.fork),
      allRepos: uniqueRepos,
      skills: {
        all: allSkills,
        categorized: categorizeSkills(allSkills)
      }
    };
  } catch (error) {
    console.error('Error fetching GitHub data:', error);
    // Fallback to JSON file if fetch fails
    const githubData = await import('@/data/github-data.json');
    return {
      pinnedRepos: githubData.pinnedRepos,
      allRepos: githubData.allRepos,
      skills: githubData.skills
    };
  }
}

function categorizeSkills(skillsArray: any[]) {
  // Create a Map from the skills array
  const skillsMap = new Map();
  skillsArray.forEach((item: any) => {
    if (typeof item === 'string') {
      // Old format - assume count of 1
      skillsMap.set(item, 1);
    } else {
      // New format with name and count
      skillsMap.set(item.name, item.count);
    }
  });
  
  // Filter skills that appear at least twice
  const filteredSkills = new Map();
  skillsMap.forEach((count, skill) => {
    if (count >= 2) {
      filteredSkills.set(skill, count);
    }
  });
  
  // Comprehensive categorization based on the issue requirements
  const categories = {
    // Languages - programming languages
    languages: new Set([
      'typescript', 'python', 'go', 'c++', 'javascript', 'c#', 'java', 'kotlin', 
      'netlogo', 'c', 'cpp', 'csharp', 'js'
    ]),
    
    // Frontend - UI/UX frameworks and libraries
    frontend: new Set([
      'svelte', 'nextjs', 'react', 'next', 'vue', 'angular', 'astro', 
      'tailwind', 'bootstrap', 'canvas'
    ]),
    
    // Backend & Databases - server-side and data storage
    backend: new Set([
      'flask', 'redis', 'node', 'express', 'django', 'spring', 'rails', 
      'laravel', 'fastapi', 'nestjs', 'postgresql', 'mysql', 'mongodb', 
      'elasticsearch', 'graphql', 'caldav-server', 'network'
    ]),
    
    // Tools & DevOps - development tools, build systems, and DevOps
    tools: new Set([
      'docker', 'kubernetes', 'jenkins', 'gitlab', 'github-actions', 
      'terraform', 'ansible', 'aws', 'azure', 'gcp', 'git', 'cmake', 
      'digital-signal-processing', 'dotenv', 'ffmpeg', 'puppeteer', 
      'headless-chrome'
    ]),
    
    // Other Technologies - everything else
    other: new Set([
      'html', 'tex', 'shaderlab', 'ai', 'linear-programming', 
      'operations-research', 'total-war', 'esports', 'icalendar', 
      'liquipedia', 'web-scraping', 'video-editing', 'keyrate', 
      'utility', 'windows', 'bot', 'tkinter', 'university', 
      'game-development', 'unity', 'dotnet', 'image', 'image-processing', 
      'inpainting', 'uwp', 'augmented-reality', 'mixed-reality', 'music', 
      'virtual-reality', 'motion-tracking', 'object-tracking', 'opencv', 
      'game-engine', 'opengl', 'qt', 'hdr', 'tensorflow', 
      'artificial-intelligence', 'dsp', 'signal-processing', 'raytracing', 
      'template', 'compression', 'security', 'game', 'genetic-algorithm'
    ])
  };
  
  const categorized = {
    languages: [] as Array<{name: string, count: number}>,
    frontend: [] as Array<{name: string, count: number}>,
    backend: [] as Array<{name: string, count: number}>,
    tools: [] as Array<{name: string, count: number}>,
    other: [] as Array<{name: string, count: number}>
  };
  
  filteredSkills.forEach((count, skill) => {
    const lowerSkill = skill.toLowerCase();
    
    // Check exact matches first
    let categorizedFlag = false;
    
    for (const [category, keywords] of Object.entries(categories)) {
      if (keywords.has(lowerSkill)) {
        (categorized as any)[category].push({ name: skill, count });
        categorizedFlag = true;
        break;
      }
    }
    
    // If no exact match, try partial matches for complex names
    if (!categorizedFlag) {
      if (['typescript', 'javascript', 'python', 'java', 'kotlin', 'c++', 'c#', 'go'].some(kw => lowerSkill.includes(kw))) {
        categorized.languages.push({ name: skill, count });
      } else if (['react', 'vue', 'svelte', 'next', 'angular', 'tailwind'].some(kw => lowerSkill.includes(kw))) {
        categorized.frontend.push({ name: skill, count });
      } else if (['flask', 'redis', 'django', 'mongodb', 'postgresql', 'mysql', 'graphql'].some(kw => lowerSkill.includes(kw))) {
        categorized.backend.push({ name: skill, count });
      } else if (['docker', 'kubernetes', 'git', 'cmake', 'terraform', 'ansible'].some(kw => lowerSkill.includes(kw))) {
        categorized.tools.push({ name: skill, count });
      } else {
        categorized.other.push({ name: skill, count });
      }
    }
  });
  
  // Sort each category by count (descending) then by name
  Object.keys(categorized).forEach(category => {
    (categorized as any)[category].sort((a: any, b: any) => {
      if (b.count !== a.count) return b.count - a.count;
      return a.name.localeCompare(b.name);
    });
  });
  
  return categorized;
}

const githubData = await fetchGitHubData();
---

<Layout>
  <div class="min-h-screen">
    <Hero client:load />
    <Projects client:load githubData={githubData} />
    <Skills client:load githubData={githubData} />
    <OtherProjects client:load githubData={githubData} />
    <Contact client:load />
    
    <footer class="py-16 px-8 border-t border-border mt-40">
      <div class="max-w-6xl mx-auto text-center text-sm text-muted-foreground">
        <p>Â© {new Date().getFullYear()} Napolitain. Built with Astro, Svelte & TypeScript.</p>
      </div>
    </footer>
  </div>
</Layout>
